/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, BytesLike } from "ethers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
  encodeCallData,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { Seaport__factory } from "./index.js";
import {
  Seaport,
  CounterIncrementedEvent,
  CounterIncrementedEventFilter,
  OrderCancelledEvent,
  OrderCancelledEventFilter,
  OrderFulfilledEvent,
  OrderFulfilledEventFilter,
  OrderValidatedEvent,
  OrderValidatedEventFilter,
  OrderComponentsStructOutput,
  OrderComponentsStruct,
  AdvancedOrderStructOutput,
  AdvancedOrderStruct,
  CriteriaResolverStructOutput,
  CriteriaResolverStruct,
  FulfillmentComponentStructOutput,
  FulfillmentComponentStruct,
  ExecutionStructOutput,
  OrderStructOutput,
  OrderStruct,
  BasicOrderParametersStructOutput,
  BasicOrderParametersStruct,
  FulfillmentStructOutput,
  FulfillmentStruct,
} from "./Seaport.js";

export interface CancelCallObject {
  orders: OrderComponentsStructOutput[];
}

export type CancelCallTrace = TypedCallTrace<
  [OrderComponentsStructOutput[]],
  CancelCallObject
>;

export interface FulfillAdvancedOrderCallObject {
  advancedOrder: AdvancedOrderStructOutput;
  criteriaResolvers: CriteriaResolverStructOutput[];
  fulfillerConduitKey: string;
  recipient: string;
}

export type FulfillAdvancedOrderCallTrace = TypedCallTrace<
  [AdvancedOrderStructOutput, CriteriaResolverStructOutput[], string, string],
  FulfillAdvancedOrderCallObject
>;

export interface FulfillAvailableAdvancedOrdersCallObject {
  advancedOrders: AdvancedOrderStructOutput[];
  criteriaResolvers: CriteriaResolverStructOutput[];
  offerFulfillments: FulfillmentComponentStructOutput[][];
  considerationFulfillments: FulfillmentComponentStructOutput[][];
  fulfillerConduitKey: string;
  recipient: string;
  maximumFulfilled: bigint;
}

export type FulfillAvailableAdvancedOrdersCallTrace = TypedCallTrace<
  [
    AdvancedOrderStructOutput[],
    CriteriaResolverStructOutput[],
    FulfillmentComponentStructOutput[][],
    FulfillmentComponentStructOutput[][],
    string,
    string,
    bigint,
  ],
  FulfillAvailableAdvancedOrdersCallObject
>;

export interface FulfillAvailableOrdersCallObject {
  orders: OrderStructOutput[];
  offerFulfillments: FulfillmentComponentStructOutput[][];
  considerationFulfillments: FulfillmentComponentStructOutput[][];
  fulfillerConduitKey: string;
  maximumFulfilled: bigint;
}

export type FulfillAvailableOrdersCallTrace = TypedCallTrace<
  [
    OrderStructOutput[],
    FulfillmentComponentStructOutput[][],
    FulfillmentComponentStructOutput[][],
    string,
    bigint,
  ],
  FulfillAvailableOrdersCallObject
>;

export interface FulfillBasicOrderCallObject {
  parameters: BasicOrderParametersStructOutput;
}

export type FulfillBasicOrderCallTrace = TypedCallTrace<
  [BasicOrderParametersStructOutput],
  FulfillBasicOrderCallObject
>;

export interface FulfillOrderCallObject {
  order: OrderStructOutput;
  fulfillerConduitKey: string;
}

export type FulfillOrderCallTrace = TypedCallTrace<
  [OrderStructOutput, string],
  FulfillOrderCallObject
>;

export interface GetCounterCallObject {
  offerer: string;
}

export type GetCounterCallTrace = TypedCallTrace<
  [string],
  GetCounterCallObject
>;

export interface GetOrderHashCallObject {
  order: OrderComponentsStructOutput;
}

export type GetOrderHashCallTrace = TypedCallTrace<
  [OrderComponentsStructOutput],
  GetOrderHashCallObject
>;

export interface GetOrderStatusCallObject {
  orderHash: string;
}

export type GetOrderStatusCallTrace = TypedCallTrace<
  [string],
  GetOrderStatusCallObject
>;

export interface IncrementCounterCallObject {}

export type IncrementCounterCallTrace = TypedCallTrace<
  [],
  IncrementCounterCallObject
>;

export interface InformationCallObject {}

export type InformationCallTrace = TypedCallTrace<[], InformationCallObject>;

export interface MatchAdvancedOrdersCallObject {
  advancedOrders: AdvancedOrderStructOutput[];
  criteriaResolvers: CriteriaResolverStructOutput[];
  fulfillments: FulfillmentStructOutput[];
}

export type MatchAdvancedOrdersCallTrace = TypedCallTrace<
  [
    AdvancedOrderStructOutput[],
    CriteriaResolverStructOutput[],
    FulfillmentStructOutput[],
  ],
  MatchAdvancedOrdersCallObject
>;

export interface MatchOrdersCallObject {
  orders: OrderStructOutput[];
  fulfillments: FulfillmentStructOutput[];
}

export type MatchOrdersCallTrace = TypedCallTrace<
  [OrderStructOutput[], FulfillmentStructOutput[]],
  MatchOrdersCallObject
>;

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface ValidateCallObject {
  orders: OrderStructOutput[];
}

export type ValidateCallTrace = TypedCallTrace<
  [OrderStructOutput[]],
  ValidateCallObject
>;

const templateContract = Seaport__factory.connect("0x0", DummyProvider);

export class SeaportContractView extends ContractView<Seaport> {
  constructor(contract: Seaport) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async getCounter(
    offerer: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("getCounter(address)")(
        offerer,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async getOrderHash(
    order: OrderComponentsStruct,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction(
        "getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))",
      )(order, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async getOrderStatus(
    orderHash: BytesLike,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<
    [boolean, boolean, bigint, bigint] & {
      isValidated: boolean;
      isCancelled: boolean;
      totalFilled: bigint;
      totalSize: bigint;
    }
  > {
    try {
      return await this.contract.getFunction("getOrderStatus(bytes32)")(
        orderHash,
        overrides || {},
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async information(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<
    [string, string, string] & {
      version: string;
      domainSeparator: string;
      conduitController: string;
    }
  > {
    try {
      return await this.contract.getFunction("information()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext,
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async cancel(
      orders: OrderComponentsStruct[],
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction(
            "cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])",
          )
          .staticCall(orders, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async fulfillAdvancedOrder(
      advancedOrder: AdvancedOrderStruct,
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction(
            "fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)",
          )
          .staticCall(
            advancedOrder,
            criteriaResolvers,
            fulfillerConduitKey,
            recipient,
            overrides || {},
          );
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async fulfillAvailableAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<
      [boolean[], ExecutionStructOutput[]] & {
        availableOrders: boolean[];
        executions: ExecutionStructOutput[];
      }
    > {
      try {
        return await this.contract
          .getFunction(
            "fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)",
          )
          .staticCall(
            advancedOrders,
            criteriaResolvers,
            offerFulfillments,
            considerationFulfillments,
            fulfillerConduitKey,
            recipient,
            maximumFulfilled,
            overrides || {},
          );
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async fulfillAvailableOrders(
      orders: OrderStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<
      [boolean[], ExecutionStructOutput[]] & {
        availableOrders: boolean[];
        executions: ExecutionStructOutput[];
      }
    > {
      try {
        return await this.contract
          .getFunction(
            "fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)",
          )
          .staticCall(
            orders,
            offerFulfillments,
            considerationFulfillments,
            fulfillerConduitKey,
            maximumFulfilled,
            overrides || {},
          );
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async fulfillBasicOrder(
      parameters: BasicOrderParametersStruct,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction(
            "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))",
          )
          .staticCall(parameters, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async fulfillOrder(
      order: OrderStruct,
      fulfillerConduitKey: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction(
            "fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)",
          )
          .staticCall(order, fulfillerConduitKey, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async incrementCounter(
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<bigint> {
      try {
        return await this.contract
          .getFunction("incrementCounter()")
          .staticCall(overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async matchAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillments: FulfillmentStruct[],
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<ExecutionStructOutput[]> {
      try {
        return await this.contract
          .getFunction(
            "matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])",
          )
          .staticCall(
            advancedOrders,
            criteriaResolvers,
            fulfillments,
            overrides || {},
          );
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async matchOrders(
      orders: OrderStruct[],
      fulfillments: FulfillmentStruct[],
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<ExecutionStructOutput[]> {
      try {
        return await this.contract
          .getFunction(
            "matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])",
          )
          .staticCall(orders, fulfillments, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async validate(
      orders: OrderStruct[],
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext,
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction(
            "validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])",
          )
          .staticCall(orders, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    cancel(
      orders: OrderComponentsStruct[],
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "cancel",
        "function cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])",
        [orders],
      );
    },
    fulfillAdvancedOrder(
      advancedOrder: AdvancedOrderStruct,
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "fulfillAdvancedOrder",
        "function fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)",
        [advancedOrder, criteriaResolvers, fulfillerConduitKey, recipient],
      );
    },
    fulfillAvailableAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "fulfillAvailableAdvancedOrders",
        "function fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)",
        [
          advancedOrders,
          criteriaResolvers,
          offerFulfillments,
          considerationFulfillments,
          fulfillerConduitKey,
          recipient,
          maximumFulfilled,
        ],
      );
    },
    fulfillAvailableOrders(
      orders: OrderStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "fulfillAvailableOrders",
        "function fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)",
        [
          orders,
          offerFulfillments,
          considerationFulfillments,
          fulfillerConduitKey,
          maximumFulfilled,
        ],
      );
    },
    fulfillBasicOrder(
      parameters: BasicOrderParametersStruct,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "fulfillBasicOrder",
        "function fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))",
        [parameters],
      );
    },
    fulfillOrder(
      order: OrderStruct,
      fulfillerConduitKey: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "fulfillOrder",
        "function fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)",
        [order, fulfillerConduitKey],
      );
    },
    getCounter(offerer: string, callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "getCounter",
        "function getCounter(address)",
        [offerer],
      );
    },
    getOrderHash(
      order: OrderComponentsStruct,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "getOrderHash",
        "function getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))",
        [order],
      );
    },
    getOrderStatus(
      orderHash: BytesLike,
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "getOrderStatus",
        "function getOrderStatus(bytes32)",
        [orderHash],
      );
    },
    incrementCounter(callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "incrementCounter",
        "function incrementCounter()",
        [],
      );
    },
    information(callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "information",
        "function information()",
        [],
      );
    },
    matchAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillments: FulfillmentStruct[],
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "matchAdvancedOrders",
        "function matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])",
        [advancedOrders, criteriaResolvers, fulfillments],
      );
    },
    matchOrders(
      orders: OrderStruct[],
      fulfillments: FulfillmentStruct[],
      callContext: EthCallContext,
    ): EthCallParam {
      return encodeCallData(
        callContext,
        "matchOrders",
        "function matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])",
        [orders, fulfillments],
      );
    },
    name(callContext: EthCallContext): EthCallParam {
      return encodeCallData(callContext, "name", "function name()", []);
    },
    validate(orders: OrderStruct[], callContext: EthCallContext): EthCallParam {
      return encodeCallData(
        callContext,
        "validate",
        "function validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])",
        [orders],
      );
    },
  };
}

export class SeaportBoundContractView extends BoundContractView<
  Seaport,
  SeaportContractView
> {
  async getCounter(offerer: string, overrides?: Overrides): Promise<bigint> {
    return await this.view.getCounter(
      offerer,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async getOrderHash(
    order: OrderComponentsStruct,
    overrides?: Overrides,
  ): Promise<string> {
    return await this.view.getOrderHash(
      order,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async getOrderStatus(
    orderHash: BytesLike,
    overrides?: Overrides,
  ): Promise<
    [boolean, boolean, bigint, bigint] & {
      isValidated: boolean;
      isCancelled: boolean;
      totalFilled: bigint;
      totalSize: bigint;
    }
  > {
    return await this.view.getOrderStatus(
      orderHash,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async information(
    overrides?: Overrides,
  ): Promise<
    [string, string, string] & {
      version: string;
      domainSeparator: string;
      conduitController: string;
    }
  > {
    return await this.view.information(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  async name(overrides?: Overrides): Promise<string> {
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      this.context.getEthCallContext(),
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async cancel(
      orders: OrderComponentsStruct[],
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.cancel(
        orders,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async fulfillAdvancedOrder(
      advancedOrder: AdvancedOrderStruct,
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.fulfillAdvancedOrder(
        advancedOrder,
        criteriaResolvers,
        fulfillerConduitKey,
        recipient,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async fulfillAvailableAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: Overrides,
    ): Promise<
      [boolean[], ExecutionStructOutput[]] & {
        availableOrders: boolean[];
        executions: ExecutionStructOutput[];
      }
    > {
      return await this.view.callStatic.fulfillAvailableAdvancedOrders(
        advancedOrders,
        criteriaResolvers,
        offerFulfillments,
        considerationFulfillments,
        fulfillerConduitKey,
        recipient,
        maximumFulfilled,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async fulfillAvailableOrders(
      orders: OrderStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: Overrides,
    ): Promise<
      [boolean[], ExecutionStructOutput[]] & {
        availableOrders: boolean[];
        executions: ExecutionStructOutput[];
      }
    > {
      return await this.view.callStatic.fulfillAvailableOrders(
        orders,
        offerFulfillments,
        considerationFulfillments,
        fulfillerConduitKey,
        maximumFulfilled,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async fulfillBasicOrder(
      parameters: BasicOrderParametersStruct,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.fulfillBasicOrder(
        parameters,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async fulfillOrder(
      order: OrderStruct,
      fulfillerConduitKey: BytesLike,
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.fulfillOrder(
        order,
        fulfillerConduitKey,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async incrementCounter(overrides?: Overrides): Promise<bigint> {
      return await this.view.callStatic.incrementCounter(
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async matchAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillments: FulfillmentStruct[],
      overrides?: Overrides,
    ): Promise<ExecutionStructOutput[]> {
      return await this.view.callStatic.matchAdvancedOrders(
        advancedOrders,
        criteriaResolvers,
        fulfillments,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async matchOrders(
      orders: OrderStruct[],
      fulfillments: FulfillmentStruct[],
      overrides?: Overrides,
    ): Promise<ExecutionStructOutput[]> {
      return await this.view.callStatic.matchOrders(
        orders,
        fulfillments,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
    async validate(
      orders: OrderStruct[],
      overrides?: Overrides,
    ): Promise<boolean> {
      return await this.view.callStatic.validate(
        orders,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        this.context.getEthCallContext(),
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    cancel(
      orders: OrderComponentsStruct[],
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.cancel(orders, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    fulfillAdvancedOrder(
      advancedOrder: AdvancedOrderStruct,
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.fulfillAdvancedOrder(
        advancedOrder,
        criteriaResolvers,
        fulfillerConduitKey,
        recipient,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    fulfillAvailableAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.fulfillAvailableAdvancedOrders(
        advancedOrders,
        criteriaResolvers,
        offerFulfillments,
        considerationFulfillments,
        fulfillerConduitKey,
        recipient,
        maximumFulfilled,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    fulfillAvailableOrders(
      orders: OrderStruct[],
      offerFulfillments: FulfillmentComponentStruct[][],
      considerationFulfillments: FulfillmentComponentStruct[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.fulfillAvailableOrders(
        orders,
        offerFulfillments,
        considerationFulfillments,
        fulfillerConduitKey,
        maximumFulfilled,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    fulfillBasicOrder(
      parameters: BasicOrderParametersStruct,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.fulfillBasicOrder(parameters, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    fulfillOrder(
      order: OrderStruct,
      fulfillerConduitKey: BytesLike,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.fulfillOrder(order, fulfillerConduitKey, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    getCounter(offerer: string, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.getCounter(offerer, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    getOrderHash(
      order: OrderComponentsStruct,
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.getOrderHash(order, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    getOrderStatus(orderHash: BytesLike, overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.getOrderStatus(orderHash, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    incrementCounter(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.incrementCounter({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    information(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.information({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    matchAdvancedOrders(
      advancedOrders: AdvancedOrderStruct[],
      criteriaResolvers: CriteriaResolverStruct[],
      fulfillments: FulfillmentStruct[],
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.matchAdvancedOrders(
        advancedOrders,
        criteriaResolvers,
        fulfillments,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: this.context.getBlockTag(overrides),
        },
      );
    },
    matchOrders(
      orders: OrderStruct[],
      fulfillments: FulfillmentStruct[],
      overrides?: Overrides,
    ): EthCallParam {
      return this.view.encodeCall.matchOrders(orders, fulfillments, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    name(overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
    validate(orders: OrderStruct[], overrides?: Overrides): EthCallParam {
      return this.view.encodeCall.validate(orders, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: this.context.getBlockTag(overrides),
      });
    },
  };
}

export type SeaportContext = ContractContext<Seaport, SeaportBoundContractView>;

export class SeaportProcessor extends BaseProcessor<
  Seaport,
  SeaportBoundContractView
> {
  onEventCounterIncremented(
    handler: (event: CounterIncrementedEvent, ctx: SeaportContext) => void,
    filter?: CounterIncrementedEventFilter | CounterIncrementedEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: CounterIncrementedEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["CounterIncremented(uint256,address)"](
        null,
        null,
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOrderCancelled(
    handler: (event: OrderCancelledEvent, ctx: SeaportContext) => void,
    filter?: OrderCancelledEventFilter | OrderCancelledEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OrderCancelledEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OrderCancelled(bytes32,address,address)"
      ](null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOrderFulfilled(
    handler: (event: OrderFulfilledEvent, ctx: SeaportContext) => void,
    filter?: OrderFulfilledEventFilter | OrderFulfilledEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OrderFulfilledEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OrderFulfilled(bytes32,address,address,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])"
      ](null, null, null, null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOrderValidated(
    handler: (event: OrderValidatedEvent, ctx: SeaportContext) => void,
    filter?: OrderValidatedEventFilter | OrderValidatedEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OrderValidatedEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OrderValidated(bytes32,address,address)"
      ](null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onCallCancel(
    handler: (call: CancelCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: CancelCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xfd9f1e10",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallFulfillAdvancedOrder(
    handler: (call: FulfillAdvancedOrderCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: FulfillAdvancedOrderCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xe7acab24",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallFulfillAvailableAdvancedOrders(
    handler: (
      call: FulfillAvailableAdvancedOrdersCallTrace,
      ctx: SeaportContext,
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: FulfillAvailableAdvancedOrdersCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x87201b41",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallFulfillAvailableOrders(
    handler: (
      call: FulfillAvailableOrdersCallTrace,
      ctx: SeaportContext,
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: FulfillAvailableOrdersCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xed98a574",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallFulfillBasicOrder(
    handler: (call: FulfillBasicOrderCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: FulfillBasicOrderCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xfb0f3ee1",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallFulfillOrder(
    handler: (call: FulfillOrderCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: FulfillOrderCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xb3a34c4c",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallGetCounter(
    handler: (call: GetCounterCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: GetCounterCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xf07ec373",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallGetOrderHash(
    handler: (call: GetOrderHashCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: GetOrderHashCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x79df72bd",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallGetOrderStatus(
    handler: (call: GetOrderStatusCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: GetOrderStatusCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x46423aa7",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallIncrementCounter(
    handler: (call: IncrementCounterCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: IncrementCounterCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x5b34b966",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallInformation(
    handler: (call: InformationCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: InformationCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xf47b7740",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallMatchAdvancedOrders(
    handler: (call: MatchAdvancedOrdersCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: MatchAdvancedOrdersCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x55944a42",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallMatchOrders(
    handler: (call: MatchOrdersCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: MatchOrdersCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0xa8174404",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  onCallValidate(
    handler: (call: ValidateCallTrace, ctx: SeaportContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: ValidateCallTrace,
      ctx: SeaportContext,
    ) => Promise<PreprocessResult>,
  ): this {
    return super.onEthTrace(
      "0x88147732",
      handler as any,
      fetchConfig,
      preprocessHandler,
    );
  }

  public static filters = {
    CounterIncremented(
      newCounter?: null,
      offerer?: string | null,
    ): CounterIncrementedEventFilter {
      return templateContract.filters["CounterIncremented(uint256,address)"](
        newCounter,
        offerer,
      );
    },
    OrderCancelled(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null,
    ): OrderCancelledEventFilter {
      return templateContract.filters[
        "OrderCancelled(bytes32,address,address)"
      ](orderHash, offerer, zone);
    },
    OrderFulfilled(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null,
      recipient?: null,
      offer?: null,
      consideration?: null,
    ): OrderFulfilledEventFilter {
      return templateContract.filters[
        "OrderFulfilled(bytes32,address,address,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])"
      ](orderHash, offerer, zone, recipient, offer, consideration);
    },
    OrderValidated(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null,
    ): OrderValidatedEventFilter {
      return templateContract.filters[
        "OrderValidated(bytes32,address,address)"
      ](orderHash, offerer, zone);
    },
  };

  protected CreateBoundContractView(): SeaportBoundContractView {
    const view = getSeaportContract(this.config.network, this.config.address);
    return new SeaportBoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): SeaportProcessor {
    if (!options.name) {
      options.name = "Seaport";
    }
    let processor = getProcessor(options) as SeaportProcessor;
    if (!processor) {
      processor = new SeaportProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class SeaportProcessorTemplate extends BaseProcessorTemplate<
  Seaport,
  SeaportBoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "Seaport";
    }
    let processor = getProcessor(options) as SeaportProcessor;
    if (!processor) {
      processor = new SeaportProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventCounterIncremented(
    handler: (event: CounterIncrementedEvent, ctx: SeaportContext) => void,
    filter?: CounterIncrementedEventFilter | CounterIncrementedEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: CounterIncrementedEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters["CounterIncremented(uint256,address)"](
        null,
        null,
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOrderCancelled(
    handler: (event: OrderCancelledEvent, ctx: SeaportContext) => void,
    filter?: OrderCancelledEventFilter | OrderCancelledEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OrderCancelledEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OrderCancelled(bytes32,address,address)"
      ](null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOrderFulfilled(
    handler: (event: OrderFulfilledEvent, ctx: SeaportContext) => void,
    filter?: OrderFulfilledEventFilter | OrderFulfilledEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OrderFulfilledEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OrderFulfilled(bytes32,address,address,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])"
      ](null, null, null, null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOrderValidated(
    handler: (event: OrderValidatedEvent, ctx: SeaportContext) => void,
    filter?: OrderValidatedEventFilter | OrderValidatedEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OrderValidatedEvent,
      ctx: SeaportContext,
      preprocessStore: { [k: string]: any },
    ) => Promise<PreprocessResult>,
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OrderValidated(bytes32,address,address)"
      ](null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }
}

export function getSeaportContract(
  chainId: EthChainId,
  address: string,
): SeaportContractView {
  let contract = getContractByABI(
    "Seaport",
    address,
    chainId,
  ) as SeaportContractView;
  if (!contract) {
    const rawContract = Seaport__factory.connect(address, getProvider(chainId as any));
    contract = new SeaportContractView(rawContract);
    addContractByABI("Seaport", address, chainId, contract);
  }
  return contract;
}

export function getSeaportContractOnContext(
  context: EthContext,
  address: string,
): SeaportBoundContractView {
  const view = getSeaportContract(context.getChainId(), address);
  const boundView = new SeaportBoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
